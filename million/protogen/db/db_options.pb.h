// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: db/db_options.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_db_2fdb_5foptions_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_db_2fdb_5foptions_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/descriptor.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_db_2fdb_5foptions_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_db_2fdb_5foptions_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_db_2fdb_5foptions_2eproto;
namespace Db {
class ColumnCacheOptions;
struct ColumnCacheOptionsDefaultTypeInternal;
extern ColumnCacheOptionsDefaultTypeInternal _ColumnCacheOptions_default_instance_;
class ColumnSqlOptions;
struct ColumnSqlOptionsDefaultTypeInternal;
extern ColumnSqlOptionsDefaultTypeInternal _ColumnSqlOptions_default_instance_;
class DbCacheOptions;
struct DbCacheOptionsDefaultTypeInternal;
extern DbCacheOptionsDefaultTypeInternal _DbCacheOptions_default_instance_;
class DbSqlOptions;
struct DbSqlOptionsDefaultTypeInternal;
extern DbSqlOptionsDefaultTypeInternal _DbSqlOptions_default_instance_;
class FieldOptionsColumn;
struct FieldOptionsColumnDefaultTypeInternal;
extern FieldOptionsColumnDefaultTypeInternal _FieldOptionsColumn_default_instance_;
class ForeignKey;
struct ForeignKeyDefaultTypeInternal;
extern ForeignKeyDefaultTypeInternal _ForeignKey_default_instance_;
class MessageOptionsTable;
struct MessageOptionsTableDefaultTypeInternal;
extern MessageOptionsTableDefaultTypeInternal _MessageOptionsTable_default_instance_;
class TableCacheOptions;
struct TableCacheOptionsDefaultTypeInternal;
extern TableCacheOptionsDefaultTypeInternal _TableCacheOptions_default_instance_;
class TableSqlOptions;
struct TableSqlOptionsDefaultTypeInternal;
extern TableSqlOptionsDefaultTypeInternal _TableSqlOptions_default_instance_;
}  // namespace Db
PROTOBUF_NAMESPACE_OPEN
template<> ::Db::ColumnCacheOptions* Arena::CreateMaybeMessage<::Db::ColumnCacheOptions>(Arena*);
template<> ::Db::ColumnSqlOptions* Arena::CreateMaybeMessage<::Db::ColumnSqlOptions>(Arena*);
template<> ::Db::DbCacheOptions* Arena::CreateMaybeMessage<::Db::DbCacheOptions>(Arena*);
template<> ::Db::DbSqlOptions* Arena::CreateMaybeMessage<::Db::DbSqlOptions>(Arena*);
template<> ::Db::FieldOptionsColumn* Arena::CreateMaybeMessage<::Db::FieldOptionsColumn>(Arena*);
template<> ::Db::ForeignKey* Arena::CreateMaybeMessage<::Db::ForeignKey>(Arena*);
template<> ::Db::MessageOptionsTable* Arena::CreateMaybeMessage<::Db::MessageOptionsTable>(Arena*);
template<> ::Db::TableCacheOptions* Arena::CreateMaybeMessage<::Db::TableCacheOptions>(Arena*);
template<> ::Db::TableSqlOptions* Arena::CreateMaybeMessage<::Db::TableSqlOptions>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Db {

// ===================================================================

class DbSqlOptions final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Db.DbSqlOptions) */ {
 public:
  inline DbSqlOptions() : DbSqlOptions(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DbSqlOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DbSqlOptions(const DbSqlOptions& from);
  DbSqlOptions(DbSqlOptions&& from) noexcept
    : DbSqlOptions() {
    *this = ::std::move(from);
  }

  inline DbSqlOptions& operator=(const DbSqlOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline DbSqlOptions& operator=(DbSqlOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DbSqlOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const DbSqlOptions* internal_default_instance() {
    return reinterpret_cast<const DbSqlOptions*>(
               &_DbSqlOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DbSqlOptions& a, DbSqlOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(DbSqlOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DbSqlOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DbSqlOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DbSqlOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DbSqlOptions& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DbSqlOptions& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Db.DbSqlOptions";
  }
  protected:
  explicit DbSqlOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Db.DbSqlOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_db_2fdb_5foptions_2eproto;
};
// -------------------------------------------------------------------

class DbCacheOptions final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Db.DbCacheOptions) */ {
 public:
  inline DbCacheOptions() : DbCacheOptions(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DbCacheOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DbCacheOptions(const DbCacheOptions& from);
  DbCacheOptions(DbCacheOptions&& from) noexcept
    : DbCacheOptions() {
    *this = ::std::move(from);
  }

  inline DbCacheOptions& operator=(const DbCacheOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline DbCacheOptions& operator=(DbCacheOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DbCacheOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const DbCacheOptions* internal_default_instance() {
    return reinterpret_cast<const DbCacheOptions*>(
               &_DbCacheOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DbCacheOptions& a, DbCacheOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(DbCacheOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DbCacheOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DbCacheOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DbCacheOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DbCacheOptions& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DbCacheOptions& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Db.DbCacheOptions";
  }
  protected:
  explicit DbCacheOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Db.DbCacheOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_db_2fdb_5foptions_2eproto;
};
// -------------------------------------------------------------------

class ForeignKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Db.ForeignKey) */ {
 public:
  inline ForeignKey() : ForeignKey(nullptr) {}
  ~ForeignKey() override;
  explicit PROTOBUF_CONSTEXPR ForeignKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ForeignKey(const ForeignKey& from);
  ForeignKey(ForeignKey&& from) noexcept
    : ForeignKey() {
    *this = ::std::move(from);
  }

  inline ForeignKey& operator=(const ForeignKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline ForeignKey& operator=(ForeignKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ForeignKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const ForeignKey* internal_default_instance() {
    return reinterpret_cast<const ForeignKey*>(
               &_ForeignKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ForeignKey& a, ForeignKey& b) {
    a.Swap(&b);
  }
  inline void Swap(ForeignKey* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ForeignKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ForeignKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ForeignKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ForeignKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ForeignKey& from) {
    ForeignKey::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ForeignKey* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Db.ForeignKey";
  }
  protected:
  explicit ForeignKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnFieldNumber = 1,
    kReferencedTableFieldNumber = 2,
    kReferencedColumnFieldNumber = 3,
    kOnDeleteFieldNumber = 4,
    kOnUpdateFieldNumber = 5,
  };
  // string column = 1;
  void clear_column();
  const std::string& column() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_column(ArgT0&& arg0, ArgT... args);
  std::string* mutable_column();
  PROTOBUF_NODISCARD std::string* release_column();
  void set_allocated_column(std::string* column);
  private:
  const std::string& _internal_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_column(const std::string& value);
  std::string* _internal_mutable_column();
  public:

  // string referenced_table = 2;
  void clear_referenced_table();
  const std::string& referenced_table() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_referenced_table(ArgT0&& arg0, ArgT... args);
  std::string* mutable_referenced_table();
  PROTOBUF_NODISCARD std::string* release_referenced_table();
  void set_allocated_referenced_table(std::string* referenced_table);
  private:
  const std::string& _internal_referenced_table() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_referenced_table(const std::string& value);
  std::string* _internal_mutable_referenced_table();
  public:

  // string referenced_column = 3;
  void clear_referenced_column();
  const std::string& referenced_column() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_referenced_column(ArgT0&& arg0, ArgT... args);
  std::string* mutable_referenced_column();
  PROTOBUF_NODISCARD std::string* release_referenced_column();
  void set_allocated_referenced_column(std::string* referenced_column);
  private:
  const std::string& _internal_referenced_column() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_referenced_column(const std::string& value);
  std::string* _internal_mutable_referenced_column();
  public:

  // string on_delete = 4;
  void clear_on_delete();
  const std::string& on_delete() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_on_delete(ArgT0&& arg0, ArgT... args);
  std::string* mutable_on_delete();
  PROTOBUF_NODISCARD std::string* release_on_delete();
  void set_allocated_on_delete(std::string* on_delete);
  private:
  const std::string& _internal_on_delete() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_on_delete(const std::string& value);
  std::string* _internal_mutable_on_delete();
  public:

  // string on_update = 5;
  void clear_on_update();
  const std::string& on_update() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_on_update(ArgT0&& arg0, ArgT... args);
  std::string* mutable_on_update();
  PROTOBUF_NODISCARD std::string* release_on_update();
  void set_allocated_on_update(std::string* on_update);
  private:
  const std::string& _internal_on_update() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_on_update(const std::string& value);
  std::string* _internal_mutable_on_update();
  public:

  // @@protoc_insertion_point(class_scope:Db.ForeignKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr referenced_table_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr referenced_column_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr on_delete_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr on_update_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2fdb_5foptions_2eproto;
};
// -------------------------------------------------------------------

class TableSqlOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Db.TableSqlOptions) */ {
 public:
  inline TableSqlOptions() : TableSqlOptions(nullptr) {}
  ~TableSqlOptions() override;
  explicit PROTOBUF_CONSTEXPR TableSqlOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableSqlOptions(const TableSqlOptions& from);
  TableSqlOptions(TableSqlOptions&& from) noexcept
    : TableSqlOptions() {
    *this = ::std::move(from);
  }

  inline TableSqlOptions& operator=(const TableSqlOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableSqlOptions& operator=(TableSqlOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableSqlOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableSqlOptions* internal_default_instance() {
    return reinterpret_cast<const TableSqlOptions*>(
               &_TableSqlOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TableSqlOptions& a, TableSqlOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(TableSqlOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableSqlOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableSqlOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableSqlOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableSqlOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableSqlOptions& from) {
    TableSqlOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableSqlOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Db.TableSqlOptions";
  }
  protected:
  explicit TableSqlOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompositeKeyFieldNumber = 3,
    kForeignKeysFieldNumber = 4,
    kCharsetFieldNumber = 1,
    kEngineFieldNumber = 2,
    kAutoIncrementFieldNumber = 5,
  };
  // repeated string composite_key = 3;
  int composite_key_size() const;
  private:
  int _internal_composite_key_size() const;
  public:
  void clear_composite_key();
  const std::string& composite_key(int index) const;
  std::string* mutable_composite_key(int index);
  void set_composite_key(int index, const std::string& value);
  void set_composite_key(int index, std::string&& value);
  void set_composite_key(int index, const char* value);
  void set_composite_key(int index, const char* value, size_t size);
  std::string* add_composite_key();
  void add_composite_key(const std::string& value);
  void add_composite_key(std::string&& value);
  void add_composite_key(const char* value);
  void add_composite_key(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& composite_key() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_composite_key();
  private:
  const std::string& _internal_composite_key(int index) const;
  std::string* _internal_add_composite_key();
  public:

  // repeated .Db.ForeignKey foreign_keys = 4;
  int foreign_keys_size() const;
  private:
  int _internal_foreign_keys_size() const;
  public:
  void clear_foreign_keys();
  ::Db::ForeignKey* mutable_foreign_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Db::ForeignKey >*
      mutable_foreign_keys();
  private:
  const ::Db::ForeignKey& _internal_foreign_keys(int index) const;
  ::Db::ForeignKey* _internal_add_foreign_keys();
  public:
  const ::Db::ForeignKey& foreign_keys(int index) const;
  ::Db::ForeignKey* add_foreign_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Db::ForeignKey >&
      foreign_keys() const;

  // string charset = 1;
  void clear_charset();
  const std::string& charset() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_charset(ArgT0&& arg0, ArgT... args);
  std::string* mutable_charset();
  PROTOBUF_NODISCARD std::string* release_charset();
  void set_allocated_charset(std::string* charset);
  private:
  const std::string& _internal_charset() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_charset(const std::string& value);
  std::string* _internal_mutable_charset();
  public:

  // string engine = 2;
  void clear_engine();
  const std::string& engine() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_engine(ArgT0&& arg0, ArgT... args);
  std::string* mutable_engine();
  PROTOBUF_NODISCARD std::string* release_engine();
  void set_allocated_engine(std::string* engine);
  private:
  const std::string& _internal_engine() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_engine(const std::string& value);
  std::string* _internal_mutable_engine();
  public:

  // bool auto_increment = 5;
  void clear_auto_increment();
  bool auto_increment() const;
  void set_auto_increment(bool value);
  private:
  bool _internal_auto_increment() const;
  void _internal_set_auto_increment(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Db.TableSqlOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> composite_key_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Db::ForeignKey > foreign_keys_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr charset_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr engine_;
    bool auto_increment_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2fdb_5foptions_2eproto;
};
// -------------------------------------------------------------------

class TableCacheOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Db.TableCacheOptions) */ {
 public:
  inline TableCacheOptions() : TableCacheOptions(nullptr) {}
  ~TableCacheOptions() override;
  explicit PROTOBUF_CONSTEXPR TableCacheOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TableCacheOptions(const TableCacheOptions& from);
  TableCacheOptions(TableCacheOptions&& from) noexcept
    : TableCacheOptions() {
    *this = ::std::move(from);
  }

  inline TableCacheOptions& operator=(const TableCacheOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableCacheOptions& operator=(TableCacheOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TableCacheOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const TableCacheOptions* internal_default_instance() {
    return reinterpret_cast<const TableCacheOptions*>(
               &_TableCacheOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TableCacheOptions& a, TableCacheOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(TableCacheOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TableCacheOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TableCacheOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TableCacheOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TableCacheOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TableCacheOptions& from) {
    TableCacheOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableCacheOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Db.TableCacheOptions";
  }
  protected:
  explicit TableCacheOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTtlFieldNumber = 1,
  };
  // int32 ttl = 1;
  void clear_ttl();
  int32_t ttl() const;
  void set_ttl(int32_t value);
  private:
  int32_t _internal_ttl() const;
  void _internal_set_ttl(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Db.TableCacheOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t ttl_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2fdb_5foptions_2eproto;
};
// -------------------------------------------------------------------

class MessageOptionsTable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Db.MessageOptionsTable) */ {
 public:
  inline MessageOptionsTable() : MessageOptionsTable(nullptr) {}
  ~MessageOptionsTable() override;
  explicit PROTOBUF_CONSTEXPR MessageOptionsTable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MessageOptionsTable(const MessageOptionsTable& from);
  MessageOptionsTable(MessageOptionsTable&& from) noexcept
    : MessageOptionsTable() {
    *this = ::std::move(from);
  }

  inline MessageOptionsTable& operator=(const MessageOptionsTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline MessageOptionsTable& operator=(MessageOptionsTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MessageOptionsTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const MessageOptionsTable* internal_default_instance() {
    return reinterpret_cast<const MessageOptionsTable*>(
               &_MessageOptionsTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MessageOptionsTable& a, MessageOptionsTable& b) {
    a.Swap(&b);
  }
  inline void Swap(MessageOptionsTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MessageOptionsTable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MessageOptionsTable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MessageOptionsTable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MessageOptionsTable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MessageOptionsTable& from) {
    MessageOptionsTable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageOptionsTable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Db.MessageOptionsTable";
  }
  protected:
  explicit MessageOptionsTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 3,
    kSqlFieldNumber = 1,
    kCacheFieldNumber = 2,
    kTickSecondFieldNumber = 4,
  };
  // string name = 3;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Db.TableSqlOptions sql = 1;
  bool has_sql() const;
  private:
  bool _internal_has_sql() const;
  public:
  void clear_sql();
  const ::Db::TableSqlOptions& sql() const;
  PROTOBUF_NODISCARD ::Db::TableSqlOptions* release_sql();
  ::Db::TableSqlOptions* mutable_sql();
  void set_allocated_sql(::Db::TableSqlOptions* sql);
  private:
  const ::Db::TableSqlOptions& _internal_sql() const;
  ::Db::TableSqlOptions* _internal_mutable_sql();
  public:
  void unsafe_arena_set_allocated_sql(
      ::Db::TableSqlOptions* sql);
  ::Db::TableSqlOptions* unsafe_arena_release_sql();

  // .Db.TableCacheOptions cache = 2;
  bool has_cache() const;
  private:
  bool _internal_has_cache() const;
  public:
  void clear_cache();
  const ::Db::TableCacheOptions& cache() const;
  PROTOBUF_NODISCARD ::Db::TableCacheOptions* release_cache();
  ::Db::TableCacheOptions* mutable_cache();
  void set_allocated_cache(::Db::TableCacheOptions* cache);
  private:
  const ::Db::TableCacheOptions& _internal_cache() const;
  ::Db::TableCacheOptions* _internal_mutable_cache();
  public:
  void unsafe_arena_set_allocated_cache(
      ::Db::TableCacheOptions* cache);
  ::Db::TableCacheOptions* unsafe_arena_release_cache();

  // int32 tick_second = 4;
  void clear_tick_second();
  int32_t tick_second() const;
  void set_tick_second(int32_t value);
  private:
  int32_t _internal_tick_second() const;
  void _internal_set_tick_second(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Db.MessageOptionsTable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::Db::TableSqlOptions* sql_;
    ::Db::TableCacheOptions* cache_;
    int32_t tick_second_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2fdb_5foptions_2eproto;
};
// -------------------------------------------------------------------

class ColumnSqlOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Db.ColumnSqlOptions) */ {
 public:
  inline ColumnSqlOptions() : ColumnSqlOptions(nullptr) {}
  ~ColumnSqlOptions() override;
  explicit PROTOBUF_CONSTEXPR ColumnSqlOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnSqlOptions(const ColumnSqlOptions& from);
  ColumnSqlOptions(ColumnSqlOptions&& from) noexcept
    : ColumnSqlOptions() {
    *this = ::std::move(from);
  }

  inline ColumnSqlOptions& operator=(const ColumnSqlOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnSqlOptions& operator=(ColumnSqlOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnSqlOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnSqlOptions* internal_default_instance() {
    return reinterpret_cast<const ColumnSqlOptions*>(
               &_ColumnSqlOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ColumnSqlOptions& a, ColumnSqlOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnSqlOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnSqlOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnSqlOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnSqlOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnSqlOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnSqlOptions& from) {
    ColumnSqlOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnSqlOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Db.ColumnSqlOptions";
  }
  protected:
  explicit ColumnSqlOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDefaultValueFieldNumber = 5,
    kCommentFieldNumber = 6,
    kPrimaryKeyFieldNumber = 1,
    kIndexFieldNumber = 2,
    kUniqueFieldNumber = 3,
    kAutoIncrementFieldNumber = 4,
    kNotNullFieldNumber = 7,
  };
  // string default_value = 5;
  void clear_default_value();
  const std::string& default_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_value();
  PROTOBUF_NODISCARD std::string* release_default_value();
  void set_allocated_default_value(std::string* default_value);
  private:
  const std::string& _internal_default_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_value(const std::string& value);
  std::string* _internal_mutable_default_value();
  public:

  // string comment = 6;
  void clear_comment();
  const std::string& comment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_comment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_comment();
  PROTOBUF_NODISCARD std::string* release_comment();
  void set_allocated_comment(std::string* comment);
  private:
  const std::string& _internal_comment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_comment(const std::string& value);
  std::string* _internal_mutable_comment();
  public:

  // bool primary_key = 1;
  void clear_primary_key();
  bool primary_key() const;
  void set_primary_key(bool value);
  private:
  bool _internal_primary_key() const;
  void _internal_set_primary_key(bool value);
  public:

  // bool index = 2;
  void clear_index();
  bool index() const;
  void set_index(bool value);
  private:
  bool _internal_index() const;
  void _internal_set_index(bool value);
  public:

  // bool unique = 3;
  void clear_unique();
  bool unique() const;
  void set_unique(bool value);
  private:
  bool _internal_unique() const;
  void _internal_set_unique(bool value);
  public:

  // bool auto_increment = 4;
  void clear_auto_increment();
  bool auto_increment() const;
  void set_auto_increment(bool value);
  private:
  bool _internal_auto_increment() const;
  void _internal_set_auto_increment(bool value);
  public:

  // bool not_null = 7;
  void clear_not_null();
  bool not_null() const;
  void set_not_null(bool value);
  private:
  bool _internal_not_null() const;
  void _internal_set_not_null(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Db.ColumnSqlOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr comment_;
    bool primary_key_;
    bool index_;
    bool unique_;
    bool auto_increment_;
    bool not_null_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2fdb_5foptions_2eproto;
};
// -------------------------------------------------------------------

class ColumnCacheOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Db.ColumnCacheOptions) */ {
 public:
  inline ColumnCacheOptions() : ColumnCacheOptions(nullptr) {}
  ~ColumnCacheOptions() override;
  explicit PROTOBUF_CONSTEXPR ColumnCacheOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ColumnCacheOptions(const ColumnCacheOptions& from);
  ColumnCacheOptions(ColumnCacheOptions&& from) noexcept
    : ColumnCacheOptions() {
    *this = ::std::move(from);
  }

  inline ColumnCacheOptions& operator=(const ColumnCacheOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnCacheOptions& operator=(ColumnCacheOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ColumnCacheOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const ColumnCacheOptions* internal_default_instance() {
    return reinterpret_cast<const ColumnCacheOptions*>(
               &_ColumnCacheOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ColumnCacheOptions& a, ColumnCacheOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnCacheOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ColumnCacheOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ColumnCacheOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ColumnCacheOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ColumnCacheOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ColumnCacheOptions& from) {
    ColumnCacheOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnCacheOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Db.ColumnCacheOptions";
  }
  protected:
  explicit ColumnCacheOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIndexFieldNumber = 1,
  };
  // bool index = 1;
  void clear_index();
  bool index() const;
  void set_index(bool value);
  private:
  bool _internal_index() const;
  void _internal_set_index(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Db.ColumnCacheOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2fdb_5foptions_2eproto;
};
// -------------------------------------------------------------------

class FieldOptionsColumn final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Db.FieldOptionsColumn) */ {
 public:
  inline FieldOptionsColumn() : FieldOptionsColumn(nullptr) {}
  ~FieldOptionsColumn() override;
  explicit PROTOBUF_CONSTEXPR FieldOptionsColumn(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldOptionsColumn(const FieldOptionsColumn& from);
  FieldOptionsColumn(FieldOptionsColumn&& from) noexcept
    : FieldOptionsColumn() {
    *this = ::std::move(from);
  }

  inline FieldOptionsColumn& operator=(const FieldOptionsColumn& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldOptionsColumn& operator=(FieldOptionsColumn&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldOptionsColumn& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldOptionsColumn* internal_default_instance() {
    return reinterpret_cast<const FieldOptionsColumn*>(
               &_FieldOptionsColumn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FieldOptionsColumn& a, FieldOptionsColumn& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldOptionsColumn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldOptionsColumn* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldOptionsColumn* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FieldOptionsColumn>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldOptionsColumn& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FieldOptionsColumn& from) {
    FieldOptionsColumn::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldOptionsColumn* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Db.FieldOptionsColumn";
  }
  protected:
  explicit FieldOptionsColumn(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSqlFieldNumber = 1,
    kCacheFieldNumber = 2,
  };
  // .Db.ColumnSqlOptions sql = 1;
  bool has_sql() const;
  private:
  bool _internal_has_sql() const;
  public:
  void clear_sql();
  const ::Db::ColumnSqlOptions& sql() const;
  PROTOBUF_NODISCARD ::Db::ColumnSqlOptions* release_sql();
  ::Db::ColumnSqlOptions* mutable_sql();
  void set_allocated_sql(::Db::ColumnSqlOptions* sql);
  private:
  const ::Db::ColumnSqlOptions& _internal_sql() const;
  ::Db::ColumnSqlOptions* _internal_mutable_sql();
  public:
  void unsafe_arena_set_allocated_sql(
      ::Db::ColumnSqlOptions* sql);
  ::Db::ColumnSqlOptions* unsafe_arena_release_sql();

  // .Db.ColumnCacheOptions cache = 2;
  bool has_cache() const;
  private:
  bool _internal_has_cache() const;
  public:
  void clear_cache();
  const ::Db::ColumnCacheOptions& cache() const;
  PROTOBUF_NODISCARD ::Db::ColumnCacheOptions* release_cache();
  ::Db::ColumnCacheOptions* mutable_cache();
  void set_allocated_cache(::Db::ColumnCacheOptions* cache);
  private:
  const ::Db::ColumnCacheOptions& _internal_cache() const;
  ::Db::ColumnCacheOptions* _internal_mutable_cache();
  public:
  void unsafe_arena_set_allocated_cache(
      ::Db::ColumnCacheOptions* cache);
  ::Db::ColumnCacheOptions* unsafe_arena_release_cache();

  // @@protoc_insertion_point(class_scope:Db.FieldOptionsColumn)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Db::ColumnSqlOptions* sql_;
    ::Db::ColumnCacheOptions* cache_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2fdb_5foptions_2eproto;
};
// ===================================================================

static const int kSqlFieldNumber = 20001;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FileOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::Db::DbSqlOptions >, 11, false >
  sql;
static const int kCacheFieldNumber = 20002;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FileOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::Db::DbCacheOptions >, 11, false >
  cache;
static const int kNameFieldNumber = 20003;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FileOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::StringTypeTraits, 9, false >
  name;
static const int kTableFieldNumber = 20001;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::MessageOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::Db::MessageOptionsTable >, 11, false >
  table;
static const int kColumnFieldNumber = 20001;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::PROTOBUF_NAMESPACE_ID::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::MessageTypeTraits< ::Db::FieldOptionsColumn >, 11, false >
  column;

// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DbSqlOptions

// -------------------------------------------------------------------

// DbCacheOptions

// -------------------------------------------------------------------

// ForeignKey

// string column = 1;
inline void ForeignKey::clear_column() {
  _impl_.column_.ClearToEmpty();
}
inline const std::string& ForeignKey::column() const {
  // @@protoc_insertion_point(field_get:Db.ForeignKey.column)
  return _internal_column();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ForeignKey::set_column(ArgT0&& arg0, ArgT... args) {
 
 _impl_.column_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Db.ForeignKey.column)
}
inline std::string* ForeignKey::mutable_column() {
  std::string* _s = _internal_mutable_column();
  // @@protoc_insertion_point(field_mutable:Db.ForeignKey.column)
  return _s;
}
inline const std::string& ForeignKey::_internal_column() const {
  return _impl_.column_.Get();
}
inline void ForeignKey::_internal_set_column(const std::string& value) {
  
  _impl_.column_.Set(value, GetArenaForAllocation());
}
inline std::string* ForeignKey::_internal_mutable_column() {
  
  return _impl_.column_.Mutable(GetArenaForAllocation());
}
inline std::string* ForeignKey::release_column() {
  // @@protoc_insertion_point(field_release:Db.ForeignKey.column)
  return _impl_.column_.Release();
}
inline void ForeignKey::set_allocated_column(std::string* column) {
  if (column != nullptr) {
    
  } else {
    
  }
  _impl_.column_.SetAllocated(column, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.column_.IsDefault()) {
    _impl_.column_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Db.ForeignKey.column)
}

// string referenced_table = 2;
inline void ForeignKey::clear_referenced_table() {
  _impl_.referenced_table_.ClearToEmpty();
}
inline const std::string& ForeignKey::referenced_table() const {
  // @@protoc_insertion_point(field_get:Db.ForeignKey.referenced_table)
  return _internal_referenced_table();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ForeignKey::set_referenced_table(ArgT0&& arg0, ArgT... args) {
 
 _impl_.referenced_table_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Db.ForeignKey.referenced_table)
}
inline std::string* ForeignKey::mutable_referenced_table() {
  std::string* _s = _internal_mutable_referenced_table();
  // @@protoc_insertion_point(field_mutable:Db.ForeignKey.referenced_table)
  return _s;
}
inline const std::string& ForeignKey::_internal_referenced_table() const {
  return _impl_.referenced_table_.Get();
}
inline void ForeignKey::_internal_set_referenced_table(const std::string& value) {
  
  _impl_.referenced_table_.Set(value, GetArenaForAllocation());
}
inline std::string* ForeignKey::_internal_mutable_referenced_table() {
  
  return _impl_.referenced_table_.Mutable(GetArenaForAllocation());
}
inline std::string* ForeignKey::release_referenced_table() {
  // @@protoc_insertion_point(field_release:Db.ForeignKey.referenced_table)
  return _impl_.referenced_table_.Release();
}
inline void ForeignKey::set_allocated_referenced_table(std::string* referenced_table) {
  if (referenced_table != nullptr) {
    
  } else {
    
  }
  _impl_.referenced_table_.SetAllocated(referenced_table, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.referenced_table_.IsDefault()) {
    _impl_.referenced_table_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Db.ForeignKey.referenced_table)
}

// string referenced_column = 3;
inline void ForeignKey::clear_referenced_column() {
  _impl_.referenced_column_.ClearToEmpty();
}
inline const std::string& ForeignKey::referenced_column() const {
  // @@protoc_insertion_point(field_get:Db.ForeignKey.referenced_column)
  return _internal_referenced_column();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ForeignKey::set_referenced_column(ArgT0&& arg0, ArgT... args) {
 
 _impl_.referenced_column_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Db.ForeignKey.referenced_column)
}
inline std::string* ForeignKey::mutable_referenced_column() {
  std::string* _s = _internal_mutable_referenced_column();
  // @@protoc_insertion_point(field_mutable:Db.ForeignKey.referenced_column)
  return _s;
}
inline const std::string& ForeignKey::_internal_referenced_column() const {
  return _impl_.referenced_column_.Get();
}
inline void ForeignKey::_internal_set_referenced_column(const std::string& value) {
  
  _impl_.referenced_column_.Set(value, GetArenaForAllocation());
}
inline std::string* ForeignKey::_internal_mutable_referenced_column() {
  
  return _impl_.referenced_column_.Mutable(GetArenaForAllocation());
}
inline std::string* ForeignKey::release_referenced_column() {
  // @@protoc_insertion_point(field_release:Db.ForeignKey.referenced_column)
  return _impl_.referenced_column_.Release();
}
inline void ForeignKey::set_allocated_referenced_column(std::string* referenced_column) {
  if (referenced_column != nullptr) {
    
  } else {
    
  }
  _impl_.referenced_column_.SetAllocated(referenced_column, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.referenced_column_.IsDefault()) {
    _impl_.referenced_column_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Db.ForeignKey.referenced_column)
}

// string on_delete = 4;
inline void ForeignKey::clear_on_delete() {
  _impl_.on_delete_.ClearToEmpty();
}
inline const std::string& ForeignKey::on_delete() const {
  // @@protoc_insertion_point(field_get:Db.ForeignKey.on_delete)
  return _internal_on_delete();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ForeignKey::set_on_delete(ArgT0&& arg0, ArgT... args) {
 
 _impl_.on_delete_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Db.ForeignKey.on_delete)
}
inline std::string* ForeignKey::mutable_on_delete() {
  std::string* _s = _internal_mutable_on_delete();
  // @@protoc_insertion_point(field_mutable:Db.ForeignKey.on_delete)
  return _s;
}
inline const std::string& ForeignKey::_internal_on_delete() const {
  return _impl_.on_delete_.Get();
}
inline void ForeignKey::_internal_set_on_delete(const std::string& value) {
  
  _impl_.on_delete_.Set(value, GetArenaForAllocation());
}
inline std::string* ForeignKey::_internal_mutable_on_delete() {
  
  return _impl_.on_delete_.Mutable(GetArenaForAllocation());
}
inline std::string* ForeignKey::release_on_delete() {
  // @@protoc_insertion_point(field_release:Db.ForeignKey.on_delete)
  return _impl_.on_delete_.Release();
}
inline void ForeignKey::set_allocated_on_delete(std::string* on_delete) {
  if (on_delete != nullptr) {
    
  } else {
    
  }
  _impl_.on_delete_.SetAllocated(on_delete, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.on_delete_.IsDefault()) {
    _impl_.on_delete_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Db.ForeignKey.on_delete)
}

// string on_update = 5;
inline void ForeignKey::clear_on_update() {
  _impl_.on_update_.ClearToEmpty();
}
inline const std::string& ForeignKey::on_update() const {
  // @@protoc_insertion_point(field_get:Db.ForeignKey.on_update)
  return _internal_on_update();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ForeignKey::set_on_update(ArgT0&& arg0, ArgT... args) {
 
 _impl_.on_update_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Db.ForeignKey.on_update)
}
inline std::string* ForeignKey::mutable_on_update() {
  std::string* _s = _internal_mutable_on_update();
  // @@protoc_insertion_point(field_mutable:Db.ForeignKey.on_update)
  return _s;
}
inline const std::string& ForeignKey::_internal_on_update() const {
  return _impl_.on_update_.Get();
}
inline void ForeignKey::_internal_set_on_update(const std::string& value) {
  
  _impl_.on_update_.Set(value, GetArenaForAllocation());
}
inline std::string* ForeignKey::_internal_mutable_on_update() {
  
  return _impl_.on_update_.Mutable(GetArenaForAllocation());
}
inline std::string* ForeignKey::release_on_update() {
  // @@protoc_insertion_point(field_release:Db.ForeignKey.on_update)
  return _impl_.on_update_.Release();
}
inline void ForeignKey::set_allocated_on_update(std::string* on_update) {
  if (on_update != nullptr) {
    
  } else {
    
  }
  _impl_.on_update_.SetAllocated(on_update, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.on_update_.IsDefault()) {
    _impl_.on_update_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Db.ForeignKey.on_update)
}

// -------------------------------------------------------------------

// TableSqlOptions

// string charset = 1;
inline void TableSqlOptions::clear_charset() {
  _impl_.charset_.ClearToEmpty();
}
inline const std::string& TableSqlOptions::charset() const {
  // @@protoc_insertion_point(field_get:Db.TableSqlOptions.charset)
  return _internal_charset();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableSqlOptions::set_charset(ArgT0&& arg0, ArgT... args) {
 
 _impl_.charset_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Db.TableSqlOptions.charset)
}
inline std::string* TableSqlOptions::mutable_charset() {
  std::string* _s = _internal_mutable_charset();
  // @@protoc_insertion_point(field_mutable:Db.TableSqlOptions.charset)
  return _s;
}
inline const std::string& TableSqlOptions::_internal_charset() const {
  return _impl_.charset_.Get();
}
inline void TableSqlOptions::_internal_set_charset(const std::string& value) {
  
  _impl_.charset_.Set(value, GetArenaForAllocation());
}
inline std::string* TableSqlOptions::_internal_mutable_charset() {
  
  return _impl_.charset_.Mutable(GetArenaForAllocation());
}
inline std::string* TableSqlOptions::release_charset() {
  // @@protoc_insertion_point(field_release:Db.TableSqlOptions.charset)
  return _impl_.charset_.Release();
}
inline void TableSqlOptions::set_allocated_charset(std::string* charset) {
  if (charset != nullptr) {
    
  } else {
    
  }
  _impl_.charset_.SetAllocated(charset, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.charset_.IsDefault()) {
    _impl_.charset_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Db.TableSqlOptions.charset)
}

// string engine = 2;
inline void TableSqlOptions::clear_engine() {
  _impl_.engine_.ClearToEmpty();
}
inline const std::string& TableSqlOptions::engine() const {
  // @@protoc_insertion_point(field_get:Db.TableSqlOptions.engine)
  return _internal_engine();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TableSqlOptions::set_engine(ArgT0&& arg0, ArgT... args) {
 
 _impl_.engine_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Db.TableSqlOptions.engine)
}
inline std::string* TableSqlOptions::mutable_engine() {
  std::string* _s = _internal_mutable_engine();
  // @@protoc_insertion_point(field_mutable:Db.TableSqlOptions.engine)
  return _s;
}
inline const std::string& TableSqlOptions::_internal_engine() const {
  return _impl_.engine_.Get();
}
inline void TableSqlOptions::_internal_set_engine(const std::string& value) {
  
  _impl_.engine_.Set(value, GetArenaForAllocation());
}
inline std::string* TableSqlOptions::_internal_mutable_engine() {
  
  return _impl_.engine_.Mutable(GetArenaForAllocation());
}
inline std::string* TableSqlOptions::release_engine() {
  // @@protoc_insertion_point(field_release:Db.TableSqlOptions.engine)
  return _impl_.engine_.Release();
}
inline void TableSqlOptions::set_allocated_engine(std::string* engine) {
  if (engine != nullptr) {
    
  } else {
    
  }
  _impl_.engine_.SetAllocated(engine, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.engine_.IsDefault()) {
    _impl_.engine_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Db.TableSqlOptions.engine)
}

// repeated string composite_key = 3;
inline int TableSqlOptions::_internal_composite_key_size() const {
  return _impl_.composite_key_.size();
}
inline int TableSqlOptions::composite_key_size() const {
  return _internal_composite_key_size();
}
inline void TableSqlOptions::clear_composite_key() {
  _impl_.composite_key_.Clear();
}
inline std::string* TableSqlOptions::add_composite_key() {
  std::string* _s = _internal_add_composite_key();
  // @@protoc_insertion_point(field_add_mutable:Db.TableSqlOptions.composite_key)
  return _s;
}
inline const std::string& TableSqlOptions::_internal_composite_key(int index) const {
  return _impl_.composite_key_.Get(index);
}
inline const std::string& TableSqlOptions::composite_key(int index) const {
  // @@protoc_insertion_point(field_get:Db.TableSqlOptions.composite_key)
  return _internal_composite_key(index);
}
inline std::string* TableSqlOptions::mutable_composite_key(int index) {
  // @@protoc_insertion_point(field_mutable:Db.TableSqlOptions.composite_key)
  return _impl_.composite_key_.Mutable(index);
}
inline void TableSqlOptions::set_composite_key(int index, const std::string& value) {
  _impl_.composite_key_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Db.TableSqlOptions.composite_key)
}
inline void TableSqlOptions::set_composite_key(int index, std::string&& value) {
  _impl_.composite_key_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Db.TableSqlOptions.composite_key)
}
inline void TableSqlOptions::set_composite_key(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.composite_key_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Db.TableSqlOptions.composite_key)
}
inline void TableSqlOptions::set_composite_key(int index, const char* value, size_t size) {
  _impl_.composite_key_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Db.TableSqlOptions.composite_key)
}
inline std::string* TableSqlOptions::_internal_add_composite_key() {
  return _impl_.composite_key_.Add();
}
inline void TableSqlOptions::add_composite_key(const std::string& value) {
  _impl_.composite_key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Db.TableSqlOptions.composite_key)
}
inline void TableSqlOptions::add_composite_key(std::string&& value) {
  _impl_.composite_key_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Db.TableSqlOptions.composite_key)
}
inline void TableSqlOptions::add_composite_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.composite_key_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Db.TableSqlOptions.composite_key)
}
inline void TableSqlOptions::add_composite_key(const char* value, size_t size) {
  _impl_.composite_key_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Db.TableSqlOptions.composite_key)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TableSqlOptions::composite_key() const {
  // @@protoc_insertion_point(field_list:Db.TableSqlOptions.composite_key)
  return _impl_.composite_key_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TableSqlOptions::mutable_composite_key() {
  // @@protoc_insertion_point(field_mutable_list:Db.TableSqlOptions.composite_key)
  return &_impl_.composite_key_;
}

// repeated .Db.ForeignKey foreign_keys = 4;
inline int TableSqlOptions::_internal_foreign_keys_size() const {
  return _impl_.foreign_keys_.size();
}
inline int TableSqlOptions::foreign_keys_size() const {
  return _internal_foreign_keys_size();
}
inline void TableSqlOptions::clear_foreign_keys() {
  _impl_.foreign_keys_.Clear();
}
inline ::Db::ForeignKey* TableSqlOptions::mutable_foreign_keys(int index) {
  // @@protoc_insertion_point(field_mutable:Db.TableSqlOptions.foreign_keys)
  return _impl_.foreign_keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Db::ForeignKey >*
TableSqlOptions::mutable_foreign_keys() {
  // @@protoc_insertion_point(field_mutable_list:Db.TableSqlOptions.foreign_keys)
  return &_impl_.foreign_keys_;
}
inline const ::Db::ForeignKey& TableSqlOptions::_internal_foreign_keys(int index) const {
  return _impl_.foreign_keys_.Get(index);
}
inline const ::Db::ForeignKey& TableSqlOptions::foreign_keys(int index) const {
  // @@protoc_insertion_point(field_get:Db.TableSqlOptions.foreign_keys)
  return _internal_foreign_keys(index);
}
inline ::Db::ForeignKey* TableSqlOptions::_internal_add_foreign_keys() {
  return _impl_.foreign_keys_.Add();
}
inline ::Db::ForeignKey* TableSqlOptions::add_foreign_keys() {
  ::Db::ForeignKey* _add = _internal_add_foreign_keys();
  // @@protoc_insertion_point(field_add:Db.TableSqlOptions.foreign_keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Db::ForeignKey >&
TableSqlOptions::foreign_keys() const {
  // @@protoc_insertion_point(field_list:Db.TableSqlOptions.foreign_keys)
  return _impl_.foreign_keys_;
}

// bool auto_increment = 5;
inline void TableSqlOptions::clear_auto_increment() {
  _impl_.auto_increment_ = false;
}
inline bool TableSqlOptions::_internal_auto_increment() const {
  return _impl_.auto_increment_;
}
inline bool TableSqlOptions::auto_increment() const {
  // @@protoc_insertion_point(field_get:Db.TableSqlOptions.auto_increment)
  return _internal_auto_increment();
}
inline void TableSqlOptions::_internal_set_auto_increment(bool value) {
  
  _impl_.auto_increment_ = value;
}
inline void TableSqlOptions::set_auto_increment(bool value) {
  _internal_set_auto_increment(value);
  // @@protoc_insertion_point(field_set:Db.TableSqlOptions.auto_increment)
}

// -------------------------------------------------------------------

// TableCacheOptions

// int32 ttl = 1;
inline void TableCacheOptions::clear_ttl() {
  _impl_.ttl_ = 0;
}
inline int32_t TableCacheOptions::_internal_ttl() const {
  return _impl_.ttl_;
}
inline int32_t TableCacheOptions::ttl() const {
  // @@protoc_insertion_point(field_get:Db.TableCacheOptions.ttl)
  return _internal_ttl();
}
inline void TableCacheOptions::_internal_set_ttl(int32_t value) {
  
  _impl_.ttl_ = value;
}
inline void TableCacheOptions::set_ttl(int32_t value) {
  _internal_set_ttl(value);
  // @@protoc_insertion_point(field_set:Db.TableCacheOptions.ttl)
}

// -------------------------------------------------------------------

// MessageOptionsTable

// .Db.TableSqlOptions sql = 1;
inline bool MessageOptionsTable::_internal_has_sql() const {
  return this != internal_default_instance() && _impl_.sql_ != nullptr;
}
inline bool MessageOptionsTable::has_sql() const {
  return _internal_has_sql();
}
inline void MessageOptionsTable::clear_sql() {
  if (GetArenaForAllocation() == nullptr && _impl_.sql_ != nullptr) {
    delete _impl_.sql_;
  }
  _impl_.sql_ = nullptr;
}
inline const ::Db::TableSqlOptions& MessageOptionsTable::_internal_sql() const {
  const ::Db::TableSqlOptions* p = _impl_.sql_;
  return p != nullptr ? *p : reinterpret_cast<const ::Db::TableSqlOptions&>(
      ::Db::_TableSqlOptions_default_instance_);
}
inline const ::Db::TableSqlOptions& MessageOptionsTable::sql() const {
  // @@protoc_insertion_point(field_get:Db.MessageOptionsTable.sql)
  return _internal_sql();
}
inline void MessageOptionsTable::unsafe_arena_set_allocated_sql(
    ::Db::TableSqlOptions* sql) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sql_);
  }
  _impl_.sql_ = sql;
  if (sql) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Db.MessageOptionsTable.sql)
}
inline ::Db::TableSqlOptions* MessageOptionsTable::release_sql() {
  
  ::Db::TableSqlOptions* temp = _impl_.sql_;
  _impl_.sql_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Db::TableSqlOptions* MessageOptionsTable::unsafe_arena_release_sql() {
  // @@protoc_insertion_point(field_release:Db.MessageOptionsTable.sql)
  
  ::Db::TableSqlOptions* temp = _impl_.sql_;
  _impl_.sql_ = nullptr;
  return temp;
}
inline ::Db::TableSqlOptions* MessageOptionsTable::_internal_mutable_sql() {
  
  if (_impl_.sql_ == nullptr) {
    auto* p = CreateMaybeMessage<::Db::TableSqlOptions>(GetArenaForAllocation());
    _impl_.sql_ = p;
  }
  return _impl_.sql_;
}
inline ::Db::TableSqlOptions* MessageOptionsTable::mutable_sql() {
  ::Db::TableSqlOptions* _msg = _internal_mutable_sql();
  // @@protoc_insertion_point(field_mutable:Db.MessageOptionsTable.sql)
  return _msg;
}
inline void MessageOptionsTable::set_allocated_sql(::Db::TableSqlOptions* sql) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sql_;
  }
  if (sql) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sql);
    if (message_arena != submessage_arena) {
      sql = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sql, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sql_ = sql;
  // @@protoc_insertion_point(field_set_allocated:Db.MessageOptionsTable.sql)
}

// .Db.TableCacheOptions cache = 2;
inline bool MessageOptionsTable::_internal_has_cache() const {
  return this != internal_default_instance() && _impl_.cache_ != nullptr;
}
inline bool MessageOptionsTable::has_cache() const {
  return _internal_has_cache();
}
inline void MessageOptionsTable::clear_cache() {
  if (GetArenaForAllocation() == nullptr && _impl_.cache_ != nullptr) {
    delete _impl_.cache_;
  }
  _impl_.cache_ = nullptr;
}
inline const ::Db::TableCacheOptions& MessageOptionsTable::_internal_cache() const {
  const ::Db::TableCacheOptions* p = _impl_.cache_;
  return p != nullptr ? *p : reinterpret_cast<const ::Db::TableCacheOptions&>(
      ::Db::_TableCacheOptions_default_instance_);
}
inline const ::Db::TableCacheOptions& MessageOptionsTable::cache() const {
  // @@protoc_insertion_point(field_get:Db.MessageOptionsTable.cache)
  return _internal_cache();
}
inline void MessageOptionsTable::unsafe_arena_set_allocated_cache(
    ::Db::TableCacheOptions* cache) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cache_);
  }
  _impl_.cache_ = cache;
  if (cache) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Db.MessageOptionsTable.cache)
}
inline ::Db::TableCacheOptions* MessageOptionsTable::release_cache() {
  
  ::Db::TableCacheOptions* temp = _impl_.cache_;
  _impl_.cache_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Db::TableCacheOptions* MessageOptionsTable::unsafe_arena_release_cache() {
  // @@protoc_insertion_point(field_release:Db.MessageOptionsTable.cache)
  
  ::Db::TableCacheOptions* temp = _impl_.cache_;
  _impl_.cache_ = nullptr;
  return temp;
}
inline ::Db::TableCacheOptions* MessageOptionsTable::_internal_mutable_cache() {
  
  if (_impl_.cache_ == nullptr) {
    auto* p = CreateMaybeMessage<::Db::TableCacheOptions>(GetArenaForAllocation());
    _impl_.cache_ = p;
  }
  return _impl_.cache_;
}
inline ::Db::TableCacheOptions* MessageOptionsTable::mutable_cache() {
  ::Db::TableCacheOptions* _msg = _internal_mutable_cache();
  // @@protoc_insertion_point(field_mutable:Db.MessageOptionsTable.cache)
  return _msg;
}
inline void MessageOptionsTable::set_allocated_cache(::Db::TableCacheOptions* cache) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cache_;
  }
  if (cache) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cache);
    if (message_arena != submessage_arena) {
      cache = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cache, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cache_ = cache;
  // @@protoc_insertion_point(field_set_allocated:Db.MessageOptionsTable.cache)
}

// string name = 3;
inline void MessageOptionsTable::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& MessageOptionsTable::name() const {
  // @@protoc_insertion_point(field_get:Db.MessageOptionsTable.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MessageOptionsTable::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Db.MessageOptionsTable.name)
}
inline std::string* MessageOptionsTable::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Db.MessageOptionsTable.name)
  return _s;
}
inline const std::string& MessageOptionsTable::_internal_name() const {
  return _impl_.name_.Get();
}
inline void MessageOptionsTable::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* MessageOptionsTable::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* MessageOptionsTable::release_name() {
  // @@protoc_insertion_point(field_release:Db.MessageOptionsTable.name)
  return _impl_.name_.Release();
}
inline void MessageOptionsTable::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Db.MessageOptionsTable.name)
}

// int32 tick_second = 4;
inline void MessageOptionsTable::clear_tick_second() {
  _impl_.tick_second_ = 0;
}
inline int32_t MessageOptionsTable::_internal_tick_second() const {
  return _impl_.tick_second_;
}
inline int32_t MessageOptionsTable::tick_second() const {
  // @@protoc_insertion_point(field_get:Db.MessageOptionsTable.tick_second)
  return _internal_tick_second();
}
inline void MessageOptionsTable::_internal_set_tick_second(int32_t value) {
  
  _impl_.tick_second_ = value;
}
inline void MessageOptionsTable::set_tick_second(int32_t value) {
  _internal_set_tick_second(value);
  // @@protoc_insertion_point(field_set:Db.MessageOptionsTable.tick_second)
}

// -------------------------------------------------------------------

// ColumnSqlOptions

// bool primary_key = 1;
inline void ColumnSqlOptions::clear_primary_key() {
  _impl_.primary_key_ = false;
}
inline bool ColumnSqlOptions::_internal_primary_key() const {
  return _impl_.primary_key_;
}
inline bool ColumnSqlOptions::primary_key() const {
  // @@protoc_insertion_point(field_get:Db.ColumnSqlOptions.primary_key)
  return _internal_primary_key();
}
inline void ColumnSqlOptions::_internal_set_primary_key(bool value) {
  
  _impl_.primary_key_ = value;
}
inline void ColumnSqlOptions::set_primary_key(bool value) {
  _internal_set_primary_key(value);
  // @@protoc_insertion_point(field_set:Db.ColumnSqlOptions.primary_key)
}

// bool index = 2;
inline void ColumnSqlOptions::clear_index() {
  _impl_.index_ = false;
}
inline bool ColumnSqlOptions::_internal_index() const {
  return _impl_.index_;
}
inline bool ColumnSqlOptions::index() const {
  // @@protoc_insertion_point(field_get:Db.ColumnSqlOptions.index)
  return _internal_index();
}
inline void ColumnSqlOptions::_internal_set_index(bool value) {
  
  _impl_.index_ = value;
}
inline void ColumnSqlOptions::set_index(bool value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:Db.ColumnSqlOptions.index)
}

// bool unique = 3;
inline void ColumnSqlOptions::clear_unique() {
  _impl_.unique_ = false;
}
inline bool ColumnSqlOptions::_internal_unique() const {
  return _impl_.unique_;
}
inline bool ColumnSqlOptions::unique() const {
  // @@protoc_insertion_point(field_get:Db.ColumnSqlOptions.unique)
  return _internal_unique();
}
inline void ColumnSqlOptions::_internal_set_unique(bool value) {
  
  _impl_.unique_ = value;
}
inline void ColumnSqlOptions::set_unique(bool value) {
  _internal_set_unique(value);
  // @@protoc_insertion_point(field_set:Db.ColumnSqlOptions.unique)
}

// bool auto_increment = 4;
inline void ColumnSqlOptions::clear_auto_increment() {
  _impl_.auto_increment_ = false;
}
inline bool ColumnSqlOptions::_internal_auto_increment() const {
  return _impl_.auto_increment_;
}
inline bool ColumnSqlOptions::auto_increment() const {
  // @@protoc_insertion_point(field_get:Db.ColumnSqlOptions.auto_increment)
  return _internal_auto_increment();
}
inline void ColumnSqlOptions::_internal_set_auto_increment(bool value) {
  
  _impl_.auto_increment_ = value;
}
inline void ColumnSqlOptions::set_auto_increment(bool value) {
  _internal_set_auto_increment(value);
  // @@protoc_insertion_point(field_set:Db.ColumnSqlOptions.auto_increment)
}

// string default_value = 5;
inline void ColumnSqlOptions::clear_default_value() {
  _impl_.default_value_.ClearToEmpty();
}
inline const std::string& ColumnSqlOptions::default_value() const {
  // @@protoc_insertion_point(field_get:Db.ColumnSqlOptions.default_value)
  return _internal_default_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnSqlOptions::set_default_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.default_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Db.ColumnSqlOptions.default_value)
}
inline std::string* ColumnSqlOptions::mutable_default_value() {
  std::string* _s = _internal_mutable_default_value();
  // @@protoc_insertion_point(field_mutable:Db.ColumnSqlOptions.default_value)
  return _s;
}
inline const std::string& ColumnSqlOptions::_internal_default_value() const {
  return _impl_.default_value_.Get();
}
inline void ColumnSqlOptions::_internal_set_default_value(const std::string& value) {
  
  _impl_.default_value_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnSqlOptions::_internal_mutable_default_value() {
  
  return _impl_.default_value_.Mutable(GetArenaForAllocation());
}
inline std::string* ColumnSqlOptions::release_default_value() {
  // @@protoc_insertion_point(field_release:Db.ColumnSqlOptions.default_value)
  return _impl_.default_value_.Release();
}
inline void ColumnSqlOptions::set_allocated_default_value(std::string* default_value) {
  if (default_value != nullptr) {
    
  } else {
    
  }
  _impl_.default_value_.SetAllocated(default_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.default_value_.IsDefault()) {
    _impl_.default_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Db.ColumnSqlOptions.default_value)
}

// string comment = 6;
inline void ColumnSqlOptions::clear_comment() {
  _impl_.comment_.ClearToEmpty();
}
inline const std::string& ColumnSqlOptions::comment() const {
  // @@protoc_insertion_point(field_get:Db.ColumnSqlOptions.comment)
  return _internal_comment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ColumnSqlOptions::set_comment(ArgT0&& arg0, ArgT... args) {
 
 _impl_.comment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Db.ColumnSqlOptions.comment)
}
inline std::string* ColumnSqlOptions::mutable_comment() {
  std::string* _s = _internal_mutable_comment();
  // @@protoc_insertion_point(field_mutable:Db.ColumnSqlOptions.comment)
  return _s;
}
inline const std::string& ColumnSqlOptions::_internal_comment() const {
  return _impl_.comment_.Get();
}
inline void ColumnSqlOptions::_internal_set_comment(const std::string& value) {
  
  _impl_.comment_.Set(value, GetArenaForAllocation());
}
inline std::string* ColumnSqlOptions::_internal_mutable_comment() {
  
  return _impl_.comment_.Mutable(GetArenaForAllocation());
}
inline std::string* ColumnSqlOptions::release_comment() {
  // @@protoc_insertion_point(field_release:Db.ColumnSqlOptions.comment)
  return _impl_.comment_.Release();
}
inline void ColumnSqlOptions::set_allocated_comment(std::string* comment) {
  if (comment != nullptr) {
    
  } else {
    
  }
  _impl_.comment_.SetAllocated(comment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.comment_.IsDefault()) {
    _impl_.comment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Db.ColumnSqlOptions.comment)
}

// bool not_null = 7;
inline void ColumnSqlOptions::clear_not_null() {
  _impl_.not_null_ = false;
}
inline bool ColumnSqlOptions::_internal_not_null() const {
  return _impl_.not_null_;
}
inline bool ColumnSqlOptions::not_null() const {
  // @@protoc_insertion_point(field_get:Db.ColumnSqlOptions.not_null)
  return _internal_not_null();
}
inline void ColumnSqlOptions::_internal_set_not_null(bool value) {
  
  _impl_.not_null_ = value;
}
inline void ColumnSqlOptions::set_not_null(bool value) {
  _internal_set_not_null(value);
  // @@protoc_insertion_point(field_set:Db.ColumnSqlOptions.not_null)
}

// -------------------------------------------------------------------

// ColumnCacheOptions

// bool index = 1;
inline void ColumnCacheOptions::clear_index() {
  _impl_.index_ = false;
}
inline bool ColumnCacheOptions::_internal_index() const {
  return _impl_.index_;
}
inline bool ColumnCacheOptions::index() const {
  // @@protoc_insertion_point(field_get:Db.ColumnCacheOptions.index)
  return _internal_index();
}
inline void ColumnCacheOptions::_internal_set_index(bool value) {
  
  _impl_.index_ = value;
}
inline void ColumnCacheOptions::set_index(bool value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:Db.ColumnCacheOptions.index)
}

// -------------------------------------------------------------------

// FieldOptionsColumn

// .Db.ColumnSqlOptions sql = 1;
inline bool FieldOptionsColumn::_internal_has_sql() const {
  return this != internal_default_instance() && _impl_.sql_ != nullptr;
}
inline bool FieldOptionsColumn::has_sql() const {
  return _internal_has_sql();
}
inline void FieldOptionsColumn::clear_sql() {
  if (GetArenaForAllocation() == nullptr && _impl_.sql_ != nullptr) {
    delete _impl_.sql_;
  }
  _impl_.sql_ = nullptr;
}
inline const ::Db::ColumnSqlOptions& FieldOptionsColumn::_internal_sql() const {
  const ::Db::ColumnSqlOptions* p = _impl_.sql_;
  return p != nullptr ? *p : reinterpret_cast<const ::Db::ColumnSqlOptions&>(
      ::Db::_ColumnSqlOptions_default_instance_);
}
inline const ::Db::ColumnSqlOptions& FieldOptionsColumn::sql() const {
  // @@protoc_insertion_point(field_get:Db.FieldOptionsColumn.sql)
  return _internal_sql();
}
inline void FieldOptionsColumn::unsafe_arena_set_allocated_sql(
    ::Db::ColumnSqlOptions* sql) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sql_);
  }
  _impl_.sql_ = sql;
  if (sql) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Db.FieldOptionsColumn.sql)
}
inline ::Db::ColumnSqlOptions* FieldOptionsColumn::release_sql() {
  
  ::Db::ColumnSqlOptions* temp = _impl_.sql_;
  _impl_.sql_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Db::ColumnSqlOptions* FieldOptionsColumn::unsafe_arena_release_sql() {
  // @@protoc_insertion_point(field_release:Db.FieldOptionsColumn.sql)
  
  ::Db::ColumnSqlOptions* temp = _impl_.sql_;
  _impl_.sql_ = nullptr;
  return temp;
}
inline ::Db::ColumnSqlOptions* FieldOptionsColumn::_internal_mutable_sql() {
  
  if (_impl_.sql_ == nullptr) {
    auto* p = CreateMaybeMessage<::Db::ColumnSqlOptions>(GetArenaForAllocation());
    _impl_.sql_ = p;
  }
  return _impl_.sql_;
}
inline ::Db::ColumnSqlOptions* FieldOptionsColumn::mutable_sql() {
  ::Db::ColumnSqlOptions* _msg = _internal_mutable_sql();
  // @@protoc_insertion_point(field_mutable:Db.FieldOptionsColumn.sql)
  return _msg;
}
inline void FieldOptionsColumn::set_allocated_sql(::Db::ColumnSqlOptions* sql) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sql_;
  }
  if (sql) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sql);
    if (message_arena != submessage_arena) {
      sql = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sql, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sql_ = sql;
  // @@protoc_insertion_point(field_set_allocated:Db.FieldOptionsColumn.sql)
}

// .Db.ColumnCacheOptions cache = 2;
inline bool FieldOptionsColumn::_internal_has_cache() const {
  return this != internal_default_instance() && _impl_.cache_ != nullptr;
}
inline bool FieldOptionsColumn::has_cache() const {
  return _internal_has_cache();
}
inline void FieldOptionsColumn::clear_cache() {
  if (GetArenaForAllocation() == nullptr && _impl_.cache_ != nullptr) {
    delete _impl_.cache_;
  }
  _impl_.cache_ = nullptr;
}
inline const ::Db::ColumnCacheOptions& FieldOptionsColumn::_internal_cache() const {
  const ::Db::ColumnCacheOptions* p = _impl_.cache_;
  return p != nullptr ? *p : reinterpret_cast<const ::Db::ColumnCacheOptions&>(
      ::Db::_ColumnCacheOptions_default_instance_);
}
inline const ::Db::ColumnCacheOptions& FieldOptionsColumn::cache() const {
  // @@protoc_insertion_point(field_get:Db.FieldOptionsColumn.cache)
  return _internal_cache();
}
inline void FieldOptionsColumn::unsafe_arena_set_allocated_cache(
    ::Db::ColumnCacheOptions* cache) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.cache_);
  }
  _impl_.cache_ = cache;
  if (cache) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Db.FieldOptionsColumn.cache)
}
inline ::Db::ColumnCacheOptions* FieldOptionsColumn::release_cache() {
  
  ::Db::ColumnCacheOptions* temp = _impl_.cache_;
  _impl_.cache_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Db::ColumnCacheOptions* FieldOptionsColumn::unsafe_arena_release_cache() {
  // @@protoc_insertion_point(field_release:Db.FieldOptionsColumn.cache)
  
  ::Db::ColumnCacheOptions* temp = _impl_.cache_;
  _impl_.cache_ = nullptr;
  return temp;
}
inline ::Db::ColumnCacheOptions* FieldOptionsColumn::_internal_mutable_cache() {
  
  if (_impl_.cache_ == nullptr) {
    auto* p = CreateMaybeMessage<::Db::ColumnCacheOptions>(GetArenaForAllocation());
    _impl_.cache_ = p;
  }
  return _impl_.cache_;
}
inline ::Db::ColumnCacheOptions* FieldOptionsColumn::mutable_cache() {
  ::Db::ColumnCacheOptions* _msg = _internal_mutable_cache();
  // @@protoc_insertion_point(field_mutable:Db.FieldOptionsColumn.cache)
  return _msg;
}
inline void FieldOptionsColumn::set_allocated_cache(::Db::ColumnCacheOptions* cache) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.cache_;
  }
  if (cache) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cache);
    if (message_arena != submessage_arena) {
      cache = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cache, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.cache_ = cache;
  // @@protoc_insertion_point(field_set_allocated:Db.FieldOptionsColumn.cache)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Db

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_db_2fdb_5foptions_2eproto
