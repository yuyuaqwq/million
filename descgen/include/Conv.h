// This file is auto-generated by Tabugen, DO NOT EDIT!
#pragma once

#include <stdarg.h>
#include <assert.h>
#include <memory>
#include <vector>
#include <sstream>
#include <string>
#include <unordered_map>
#include "rapidcsv.h"


#define TabDelim1 ('|')
#define TabDelim2 (':')


inline void stringAppendV(std::string* dst, const char* format, va_list ap) {
    // First try with a small fixed size buffer
    static const int kSpaceLength = 1024;
    char space[kSpaceLength];

    // It's possible for methods that use a va_list to invalidate
    // the data in it upon use.  The fix is to make a copy
    // of the structure before using it and use that copy instead.
    va_list backup_ap;
    va_copy(backup_ap, ap);
    int result = vsnprintf(space, kSpaceLength, format, backup_ap);
    va_end(backup_ap);

    if (result < kSpaceLength) {
        if (result >= 0) {
            // Normal case -- everything fit.
            dst->append(space, result);
            return;
        }

#ifdef _MSC_VER
        {
            // Error or MSVC running out of space.  MSVC 8.0 and higher
            // can be asked about space needed with the special idiom below:
            va_copy(backup_ap, ap);
            result = vsnprintf(nullptr, 0, format, backup_ap);
            va_end(backup_ap);
        }
#endif

        if (result < 0) {
            // Just an error.
            return;
        }
    }

    // Increase the buffer size to the size requested by vsnprintf,
    // plus one for the closing  .
    int length = result + 1;
    std::unique_ptr<char> buf(new char[length]);

    // Restore the va_list before we use it again
    va_copy(backup_ap, ap);
    result = vsnprintf(buf.get(), length, format, backup_ap);
    va_end(backup_ap);

    if (result >= 0 && result < length) {
        // It fit
        dst->append(buf.get(), result);
    }
}

inline std::string stringPrintf(const char* format, ...)
{
    va_list ap;
    va_start(ap, format);
    std::string result;
    stringAppendV(&result, format, ap);
    va_end(ap);
    return result;
}


template <typename T>
inline T ParseField(const std::string& text)
{
    std::istringstream iss(text);
    T value;
    iss >> value;
    return value;
}

template <typename T>
std::vector<T> ParseArrayField(const std::string& text)
{
    std::vector<T> result;
    std::istringstream iss(text);
    std::string part;

    while (std::getline(iss, part, TabDelim1)) // Assuming TabDelim1 is a tab character
    {
        result.push_back(ParseField<T>(part));
    }
    return result;
}

template <typename K, typename V>
std::unordered_map<K, V> ParseMapField(const std::string& text)
{
    std::unordered_map<K, V> result;
    std::istringstream iss(text);
    std::string part;

    while (std::getline(iss, part, TabDelim1)) // Assuming TabDelim1 is a tab character
    {
        std::istringstream kvStream(part);
        std::string keyStr, valStr;

        if (std::getline(kvStream, keyStr, TabDelim2) && std::getline(kvStream, valStr, TabDelim2)) // Assuming TabDelim2 is a tab character
        {
            auto key = ParseField<K>(keyStr);
            auto val = ParseField<V>(valStr);
            assert(result.count(key) == 0); // Ensure the key is unique
            result.emplace(std::move(key), std::move(val));
        }
    }
    return result;
}

template <typename T>
inline T GetCellByName(const rapidcsv::Document& doc, const std::string& name, int rowIndex) {
    int colIdx = doc.GetColumnIdx(name);
    if (colIdx >= 0) {
        return doc.GetCell<T>(colIdx, rowIndex);
    }
    return T();
}

inline const std::string& GetTableField(const std::unordered_map<std::string, std::string>& table, const std::string& name) {
    auto iter = table.find(name);
    if (iter != table.end()) {
        return iter->second;
    }
    static std::string zero;
    return zero;
}
